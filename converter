from pathlib import Path
import markdown2
import re

# === Helper: Slugify filenames and wiki-links ===
def slugify(text):
    return re.sub(r"[^\w\-]", "", text.strip().replace(" ", ""))

# === Base directories ===
base = Path(__file__).resolve().parent
input_dir = base / "material_database"
output_dir = base / "public_database" / "lauren_public"
output_dir.mkdir(parents=True, exist_ok=True)

# === Whitelist file and manual mappings ===
whitelist_path = base / "pages_to_publish.txt"

folder_to_output = {
    "database/lauren_directory.md": {
        "template": base / "public_database" / "lauren_public" / "nc_template.html",
        "filename": output_dir / "nc_index.html"
    },
    "deva": {
        "template": base / "fm_template.html",
        "filename": output_dir / "Ferromagneticealloy.html"
    }
}

# === Markdown processor with wiki link handling ===
def process_markdown(content):
    if "<!-- PUBLISH STOP -->" in content:
        content = content.split("<!-- PUBLISH STOP -->", 1)[0].strip()

    # Wiki-link conversion: [[1 Alloy|Alt Text]] or [[1 Alloy]]
    content = re.sub(
        r"\[\[([^\[\]|]+)(\|([^\]]+))?\]\]",
        lambda m: f'<a href="{slugify(m.group(1))}.html">{m.group(3) or m.group(1).strip()}</a>',
        content,
    )

    # Embedded image handling: ![[image.png]]
    content = re.sub(r"!\[\[([^\]]+)\]\]", r'<img src="\1" alt="\1">', content)

    return markdown2.markdown(content, extras=["fenced-code-blocks", "tables", "footnotes"])

# === Generate index/static pages from whitelist ===
if whitelist_path.exists():
    with whitelist_path.open("r", encoding="utf-8") as f:
        for line in f:
            item = line.strip().rstrip("/")
            if not item or item.startswith("#"):
                continue

            if item not in folder_to_output:
                print(f"\u26a0\ufe0f Item '{item}' not mapped to an output file — skipping.")
                continue

            path = input_dir / item
            all_md = []

            try:
                if path.is_file():
                    md_content = path.read_text(encoding="utf-8")
                    html_piece = process_markdown(md_content)
                    all_md.append(html_piece)

                elif path.is_dir():
                    for md_file in sorted(path.rglob("*.md")):
                        if md_file.name.startswith(("_", ".")):
                            continue
                        md_content = md_file.read_text(encoding="utf-8")
                        html_piece = process_markdown(md_content)
                        all_md.append(html_piece)
                else:
                    print(f"❌ Path '{item}' not found in vault — skipping.")
                    continue

                combined_html = "\n\n<hr/>\n\n".join(all_md)
                output_info = folder_to_output[item]
                template_path = output_info["template"]
                out_file = output_info["filename"]

                if not template_path.exists():
                    print(f"❌ Template '{template_path}' not found — skipping.")
                    continue

                template = template_path.read_text(encoding="utf-8")
                final_html = template.replace("<!-- CONTENT GOES HERE -->", combined_html)
                out_file.write_text(final_html, encoding="utf-8")
                print(f"✅ Created combined page: {out_file.relative_to(base)}")

            except Exception as e:
                print(f"❌ Error processing '{item}': {e}")

# === Generate material pages (nested folders per alloy) ===
material_root = input_dir / "lauren"
material_output_root = output_dir / "nc_alloys"
material_template = base / "public_database" / "material_template.html"

if not material_template.exists():
    print(f"❌ Material template '{material_template}' not found — skipping material pages.")
else:
    for md_file in sorted(material_root.rglob("*.md")):
        if md_file.name.lower() == "lauren_directory.md" or not md_file.suffix == ".md":
            continue
        if md_file.name.startswith(("_", ".")):
            continue

        try:
            relative_path = md_file.relative_to(material_root)
            output_path = material_output_root / relative_path.parent
            output_path.mkdir(parents=True, exist_ok=True)
            slug = slugify(md_file.stem)
            out_file = output_path / f"{slug}.html"

            md_content = md_file.read_text(encoding="utf-8")
            html_content = process_markdown(md_content)
            template = material_template.read_text(encoding="utf-8")

            title = md_content.strip().split("\n", 1)[0].lstrip("#").strip()
            final_html = template.replace("<!-- CONTENT GOES HERE -->", html_content)
            final_html = final_html.replace("<!-- TITLE GOES HERE -->", title)

            out_file.write_text(final_html, encoding="utf-8")
            print(f"✅ Created material page: {out_file.relative_to(base)}")

        except Exception as e:
            print(f"❌ Error processing material file '{md_file}': {e}")
